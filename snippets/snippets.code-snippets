{
    "Selection Sort": {
        "prefix": "$slctn-srt",
        "body": [
            "let selectionSort = (inputArr) => { ",
            "    let n = inputArr.length;",
            "        ",
            "    for(let i = 0; i < n; i++) {",
            "        // Finding the smallest number in the subarray",
            "        let min = i;",
            "        for(let j = i+1; j < n; j++){",
            "            if(inputArr[j] < inputArr[min]) {",
            "                min=j; ",
            "            }",
            "         }",
            "         if (min != i) {",
            "             // Swapping the elements",
            "             let tmp = inputArr[i]; ",
            "             inputArr[i] = inputArr[min];",
            "             inputArr[min] = tmp;      ",
            "        }",
            "    }",
            "    return inputArr;",
            "};",
            "console.log(selectionSort(${1:arrHere}))",
        ],
        "description": "Selection Sorting Algorithm"
    },
    "Insertion Sort": {
        "prefix": "$ins-srt",
        "body": [
            "let insertionSort = (inputArr) => {",
            "    let n = inputArr.length;",
            "        for (let i = 1; i < n; i++) {",
            "            // Choosing the first element in our unsorted subarray",
            "            let current = inputArr[i];",
            "            // The last element of our sorted subarray",
            "            let j = i-1; ",
            "            while ((j > -1) && (current < inputArr[j])) {",
            "                inputArr[j+1] = inputArr[j];",
            "                j--;",
            "            }",
            "            inputArr[j+1] = current;",
            "        }",
            "    return inputArr;",
            "};",
            "console.log(insertionSort(${1:arrHere}))",
        ],
        "description": "Insertion Sorting Algorithm"
    },
    "Bubble Sort": {
        "prefix": "$bbl-srt",
        "body": [
            "let bubbleSort = (inputArr) => {",
            "    let len = inputArr.length;",
            "    for (let i = 0; i < len; i++) {",
            "        for (let j = 0; j < len; j++) {",
            "            if (inputArr[j] > inputArr[j + 1]) {",
            "                let tmp = inputArr[j];",
            "                inputArr[j] = inputArr[j + 1];",
            "                inputArr[j + 1] = tmp;",
            "            }",
            "        }",
            "    }",
            "    return inputArr;",
            "};",
            "console.log(bubbleSort(${1:arrHere}))",
        ],
        "description": "Bubble Sorting Algorithm"
    },
    "Shell Sort": {
        "prefix": "$shell-srt",
        "body": [
            "let shellSort = (inputArr) => {",
            "    let n = inputArr.length;",
            "    for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2))   {",
            "        for (let i = gap; i < n; i += 1)  {",
            "            let temp = inputArr[i];",
            "            let j;",
            "            for (j = i; j >= gap && inputArr[j-gap] > temp; j-=gap)  {",
            "                inputArr[j] = inputArr[j-gap];",
            "            }",
            "            inputArr[j] = temp;",
            "        }",
            "    }",
            "    return inputArr;",
            "};",
            "console.log(shellSort(${1:arrHere}))",
        ],
        "description": "Shell Sorting Algorithm"
    },
    "Merge Sort": {
        "prefix": "$mrg-srt",
        "body": [
            "let merge = (left, right) => {",
            "    let arr = []",
            "    while (left.length && right.length) {",
            "        if (left[0] < right[0]) {",
            "            arr.push(left.shift())  ",
            "        } else {",
            "            arr.push(right.shift()) ",
            "        }",
            "    }",
            "    return [ ...arr, ...left, ...right ]",
            "};",
            "",
            "let mergeSort = (array) => {",
            "    const half = array.length / 2",
            "    if(array.length < 2){",
            "        return array ",
            "    }",
            "    const left = array.splice(0, half)",
            "    return merge(mergeSort(left),mergeSort(array))",
            "};",
            "console.log(mergeSort(${1:arrHere}))",
        ],
        "description": "Merge Sorting Algorithm"
    },
    "Quick Sort": {
        "prefix": "$qk-srt",
        "body": [
            "let partition = (arr, start, end) => {",
            "    const pivotValue = arr[end];",
            "    let pivotIndex = start; ",
            "    for (let i = start; i < end; i++) {",
            "        if (arr[i] < pivotValue) {",
            "        [arr[i], arr[pivotIndex]] = [arr[pivotIndex], arr[i]];",
            "        pivotIndex++;",
            "        }",
            "    }",
            "    [arr[pivotIndex], arr[end]] = [arr[end], arr[pivotIndex]] ",
            "    return pivotIndex;",
            "};",
            "",
            "function quickSortRecursive(arr, start, end) {",
            "    if (start >= end) return;",
            "    let index = partition(arr, start, end);",
            "    quickSort(arr, start, index - 1);",
            "    quickSort(arr, index + 1, end);",
            "};",
            "console.log(quickSortRecursive(${1:arrHere}))",
        ],
        "description": "Quick Sorting Algorithm"
    },
    "Heap Sort": {
        "prefix": "$hp-srt",
        "body": [
            "const maxHeapify = (arr, n, i) => {",
            "    let largest = i;",
            "    let l = 2 * i + 1; //left child index",
            "    let r = 2 * i + 2; //right child index",
            "  ",
            "    if (l < n && arr[l] > arr[largest]) largest = l;",
            "  ",
            "    if (r < n && arr[r] > arr[largest]) largest = r;",
            "  ",
            "    if (largest != i) { ",
            "        let temp = arr[i];",
            "        arr[i] = arr[largest];",
            "        arr[largest] = temp;",
            "        maxHeapify(arr, n, largest);",
            "    }",
            "};",
            "",
            "const heapSort = (arr, n) => { ",
            "    for (let i = parseInt(n / 2 - 1); i >= 0; i--) maxHeapify(arr, n, i);",
            "    ",
            "    for (let i = n - 1; i >= 0; i--) {",
            "        let temp = arr[0];",
            "        arr[0] = arr[i];",
            "        arr[i] = temp;",
            "        maxHeapify(arr, i, 0);",
            "    }",
            "};",
            "console.log(heapSort(${1:arrHere}, ${2:arrLengthHere}))",
        ],
        "description": "Heap Sorting Algorithm"
    },
    "Counting Sort": {
        "prefix": "$cnt-srt",
        "body": [
            "let countingSort = (arr, min, max) => {",
            "    let i = min,",
            "        j = 0,",
            "        len = arr.length,",
            "        count = [];",
            "    for (i; i <= max; i++) count[i] = 0;",
            "    for (i = 0; i < len; i++) count[arr[i]] += 1;",
            "    for (i = min; i <= max; i++) {",
            "        while (count[i] > 0) {",
            "            arr[j] = i;",
            "            j++;",
            "            count[i]--;",
            "        }",
            "    }",
            "    return arr;",
            "};",
            "console.log(countingSort(${1:arrHere}, ${2:minValHere}, ${3:maxValHere}))",
        ],
        "description": "Counting Sort Algorithm"
    },
    "Radix Sort": {
        "prefix": "$rx-srt",
        "body": [
            "const getDigitAtPosition = (num, atPosition) => Math.floor(Math.abs(num) / Math.pow(10, atPosition)) % 10",
            "",
            "const radixSort = (arr) => {",
            "    if (!arr.length || arr.length === 1) return arr",
            "",
            "    let biggestNumber = arr[arr.length-1]",
            "    for (let i = 0; i < arr.length; i++) {",
            "        if (arr[i] > biggestNumber) biggestNumber = arr[i]",
            "    }",
            "    const biggestNumberPositionsCount = biggestNumber.toString().length",
            "  ",
            "    for (let position = 0; position < biggestNumberPositionsCount; position++) {",
            "        let buckets = Array.from({length:10}, () => []) ",
            "    ",
            "        for (let i = 0; i < arr.length; i++) {",
            "            buckets[getDigitAtPosition(arr[i], position)].push(arr[i])",
            "        }",
            "        arr = [].concat(...buckets)",
            "    }",
            "    return arr",
            "};",
            "console.log(radixSort(${1:arrHere}))",
        ],
        "description": "Radix Sorting Algorithm"
    },
    "Linear Search": {
        "prefix": "$lin-srch",
        "body": [
            "let linearSearch = (arr, value) => {",
            "    let found = false;",
            "    let position = -1;",
            "    let index = 0;",
            "  ",
            "    while(!found && index < arr.length) {",
            "        if(arr[index] == value) {",
            "            found = true;",
            "            position = index;",
            "        } else {",
            "            index += 1;",
            "        }",
            "    }",
            "    return position;",
            "};",
            "console.log(linearSearch(${1:arrHere}, ${2:targetValHere}))",
        ],
        "description": "Linear Search Algorithm"
    },
    "Binary Search": {
        "prefix": "$bi-srch",
        "body": [
            "let binarySearch = (sortedArray, target) => {",
            "    let start = 0;",
            "    let end = sortedArray.length - 1;",
            "",
            "    while (start <= end) {",
            "        let middle = Math.floor((start + end) / 2);",
            "",
            "        if (sortedArray[middle] === target) {",
            "            return middle;",
            "        } else if (sortedArray[middle] < target) {",
            "            start = middle + 1;",
            "        } else {",
            "            end = middle - 1;",
            "        }",
            "    }",
            "    return -1;",
            "};",
            "console.log(binarySearch(${1:sortedArrHere}, ${2:targetValHere}))",
        ],
        "description": "Binary Search Algorithm"
    },
    "Jump Search": {
        "prefix": "$jmp-srch",
        "body": [
            "let jumpSearch = (arr, target) => {",
            "    let len = arr.length",
            "    let step = Math.floor(Math.sqrt(len));",
            "    let blockStart = 0, currentStep = step;",
            "",
            "    while (arr[Math.min(currentStep, len) - 1] < target) {",
            "        blockStart = currentStep;",
            "        currentStep += step;",
            "        if (blockStart >= len) return -1;",
            "    }",
            "    while (arr[blockStart] < target) {",
            "        blockStart++;",
            "        if (blockStart == Math.min(currentStep, len)) return -1;",
            "    }",
            "    return (arr[blockStart] == target) ? blockStart : -1",
            "};",
            "console.log(jumpSearch(${1:arrHere}, ${2:targetValHere}))",
        ],
        "description": "Jump Search Algorithm"
    },
    "Interpolation Search": {
        "prefix": "$intrpl-srch",
        "body": [
            "let interpolationSearch = (sortedArr, target) => {",
            "    let left = 0;",
            "    let right = sortedArr.length - 1;",
            "    while (left <= right) {",
            "        const rangeDelta = sortedArr[right] - sortedArr[left];",
            "        const indexDelta = right - left;",
            "        const valueDelta = target - sortedArr[left];",
            "        ",
            "        if (valueDelta < 0) return -1;",
            "        if (!rangeDelta) return sortedArr[left] === target ? left : -1;",
            "        ",
            "        const middleIndex = left + Math.floor((valueDelta * indexDelta) / rangeDelta);",
            "        ",
            "        if (sortedArr[middleIndex] === target) return middleIndex;",
            "        if (sortedArr[middleIndex] < target)",
            "            left = middleIndex + 1;",
            "        else",
            "            right = middleIndex - 1;",
            "    }",
            "    return -1;",
            "};",
            "console.log(interpolation(${1:sortedArrHere}, ${2:targetValHere}))",
        ],
        "description": "Interpolation Search Algorithm"
    },
    "Fibonacci Search": {
        "prefix": "$fib-srch",
        "body": [
            "let fibMonaccianSearch = (arr, target, n) => {",
            "    let fibMMm2 = 0;",
            "    let fibMMm1 = 1;",
            "    let fibM = fibMMm2 + fibMMm1;",
            "  ",
            "    while (fibM < n) {",
            "        fibMMm2 = fibMMm1;",
            "        fibMMm1 = fibM;",
            "        fibM = fibMMm2 + fibMMm1;",
            "    }",
            "    let offset = -1;",
            "    ",
            "    while (fibM > 1) {",
            "        let i = Math.min(offset + fibMMm2, n-1);",
            "        if (arr[i] < target) {",
            "            fibM = fibMMm1;",
            "            fibMMm1 = fibMMm2;",
            "            fibMMm2 = fibM - fibMMm1;",
            "            offset = i;",
            "        } else if (arr[i] > target) {",
            "            fibM = fibMMm2;",
            "            fibMMm1 = fibMMm1 - fibMMm2;",
            "            fibMMm2 = fibM - fibMMm1;",
            "        }",
            "        else return i;",
            "    }",
            "",
            "    if (fibMMm1 && arr[n-1] == target) return n-1;",
            "  ",
            "    // element not found. return -1",
            "    return -1;",
            "};",
            "console.log(fibMonaccianSearch(${1:arrHere}, ${2:targetValHere}, ${3:arrLengthHere}))",
        ],
        "description": "Fibonacci Search Algorithm"
    },
    "Array": {
        "prefix": "#arr",
        "body": [
            "const arrName = [\"el1\", \"el2\", \"el3\"]",
        ],
        "description": "Create Array"
    },
    "Array Uniques": {
        "prefix": "#arr-uniques",
        "body": [
            "const getUniqueValues = (arrOfNum) => {",
                "const set = new Set(arrOfNum);",
                "return [...set];",
            "}"
        ],
        "description": "Return Unique Values of Array"
    },
    "Array Permutations": {
        "prefix": "#arr-permutations",
        "body": [
            "const permute = (nums) => {",
            "    let result = [];",
            "    let backtrack = (i, nums) => {",
            "        if(i===nums.length){",
            "            result.push(nums.slice());",
            "            return;",
            "        }  ",
            "        for(let j = i; j < nums.length; j++){",
            "            [nums[i],nums[j]] = [nums[j],nums[i]];",
            "            backtrack(i+1, nums);",
            "            [nums[i],nums[j]] = [nums[j],nums[i]];",
            "        }",
            "    }",
            "    backtrack(0, nums);",
            "    return result;",
            "};",
            "const permutations = permute(${1:arrHere});"
        ],
        "description": "Return 2D Array of Possible Permutations"
    },
    "Array Shuffle": {
        "prefix": "#arr-shuffle",
        "body": [
            "const shuffleArray = array => {",
            "    for (let i = array.length - 1; i > 0; i--) {",
            "        const j = Math.floor(Math.random() * (i + 1));",
            "        [array[i], array[j]] = [array[j], array[i]];",
            "    }",
            "};",
            "",
            "shuffleArray(${1:arrHere});",
            "console.log(${1:arrHere});",
        ],
        "description": "Return Shuffled Array"
    },
    "Array For-Each Traversal": {
        "prefix": "#arr-trav",
        "body": [
            "${1:arrHere}.forEach((item, index) => {",
            "    console.log(item, index);",
            "});",
        ],
        "description": "For-Each Traversal of Array"
    },
    "Array For-Each Reverse Traversal": {
        "prefix": "#arr-revtrav",
        "body": [
            "${1:arrHere}.slice().reverse().forEach((item, index) => {",
            "    console.log(item, index);",
            "});",
        ],
        "description": "For-Each Reverse Traversal of Array"
    },
    "Queue (Class Implementation)": {
        "prefix": "#queue",
        "body": [
            "class Queue {",
            "    constructor() {",
            "        this.items = {};",
            "        this.headIndex = 0;",
            "        this.tailIndex = 0;",
            "    }",
            "    enqueue(item) {",
            "        this.items[this.tailIndex] = item;",
            "        this.tailIndex++;",
            "    }",
            "    dequeue() {",
            "        const item = this.items[this.headIndex];",
            "        delete this.items[this.headIndex];",
            "        this.headIndex++;",
            "        return item;",
            "    }",
            "    peek() {",
            "        return this.items[this.headIndex];",
            "    }",
            "    get length() {",
            "        return this.tailIndex - this.headIndex;",
            "    }",
            "}",
            "const queue = new Queue();",
            "queue.enqueue(7);",
            "queue.enqueue(2);",
            "queue.enqueue(6);",
            "queue.enqueue(4);",
            "queue.dequeue(); // 7",
            "queue.peek();    // 2",
            "queue.length;    // 3",
        ],
        "description": "Class Implementation of Queue"
    },
    "Stack (Class Implementation)": {
        "prefix": "#stack",
        "body": [
            "class Stack {",
            "    constructor() {",
            "        this.items = [];",
            "    }",
            "    ",
            "    push(element) {",
            "        this.items.push(element);",
            "    }",
            "    ",
            "    pop() {",
            "        if (this.items.length == 0) return \"Underflow\";",
            "        return this.items.pop();",
            "    }",
            "",
            "    peek() {",
            "        return this.items[this.items.length - 1];",
            "    }",
            "",
            "    isEmpty() {",
            "        return this.items.length == 0;",
            "    }",
            "",
            "    printStack() {",
            "        var str = \"\";",
            "        for (var i = 0; i < this.items.length; i++)",
            "            str += this.items[i] + \" \";",
            "        return str;",
            "    }",
            "}",
            "",
            "// Adding element to the stack",
            "stack.push(10);",
            "stack.push(20);",
            "stack.push(30);",
            "",
            "// Printing the stack element",
            "// prints [10, 20, 30]",
            "console.log(stack.printStack());",
            "",
            "// returns 30",
            "console.log(stack.peek());",
            "",
            "// returns 30 and remove it from stack",
            "console.log(stack.pop());",
            "",
            "// returns [10, 20]",
            "console.log(stack.printStack());",
        ],
        "description": "Class Implementation of Stack"
    },
    "Map": {
        "prefix": "#map",
        "body": [
            "var hashmap = new Map();",
            "",
            "hashmap.set('1', 99);",
            "hashmap.set('2', [1,2,3]);",
            "hashmap.set('3', \"This is a string\");",
            "hashmap.set('4', ()=>{console.log(\"Hello World\")});",
            "",
            "console.log(hashmap);",
        ],
        "description": "Create Map"
    },
    "Map Traversal": {
        "prefix": "#map-trav",
        "body": [
            "hashmap.forEach(element => {",
                "document.write('<br>'+element);",
            "});",
        ],
        "description": "For-Each Traversal of Map"
    },
    "Tree": {
        "prefix": "#tree",
        "body": [
            "class TreeNode {",
            "    constructor(key, value = key, parent = null) {",
            "        this.key = key;",
            "        this.value = value;",
            "        this.parent = parent;",
            "        this.children = [];",
            "    }",
            "",
            "    get isLeaf() {",
            "        return this.children.length === 0;",
            "    }",
            "",
            "    get hasChildren() {",
            "        return !this.isLeaf;",
            "    }",
            "}",
            "",
            "class Tree {",
            "    constructor(key, value = key) {",
            "        this.root = new TreeNode(key, value);",
            "    }",
            "",
            "    *preOrderTraversal(node = this.root) {",
            "        yield node;",
            "        if (node.children.length) {",
            "            for (let child of node.children) {",
            "                yield* this.preOrderTraversal(child);",
            "            }",
            "        }",
            "    }",
            "",
            "    *postOrderTraversal(node = this.root) {",
            "        if (node.children.length) {",
            "            for (let child of node.children) {",
            "                yield* this.postOrderTraversal(child);",
            "            }",
            "        }",
            "        yield node;",
            "    }",
            "",
            "    insert(parentNodeKey, key, value = key) {",
            "        for (let node of this.preOrderTraversal()) {",
            "            if (node.key === parentNodeKey) {",
            "                node.children.push(new TreeNode(key, value, node));",
            "                return true;",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "",
            "    remove(key) {",
            "        for (let node of this.preOrderTraversal()) {",
            "            const filtered = node.children.filter(c => c.key !== key);",
            "            if (filtered.length !== node.children.length) {",
            "                node.children = filtered;",
            "                return true;",
            "            }",
            "        }",
            "        return false;",
            "    }",
            "",
            "    find(key) {",
            "        for (let node of this.preOrderTraversal()) {",
            "            if (node.key === key) return node;",
            "        }",
            "        return undefined;",
            "    }",
            "}",
        ],
        "description": "Class Implementation of Tree"
    },
    "Binary Search Tree": {
        "prefix": "#tree-bst",
        "body": [
            "class Node{",
            "    constructor(data) {",
            "        this.data = data;",
            "        this.left = null;",
            "        this.right = null;",
            "    }",
            "};",
            "",
            "class BinarySearchTree{",
            "    constructor(){",
            "        this.root = null;",
            "    }",
            "    insert(data){",
            "        var newNode = new Node(data);",
            "        if (this.root === null)",
            "            this.root = newNode;",
            "        else",
            "            this.insertNode(this.root, newNode);",
            "    };",
            "    insertNode(node, newNode){",
            "        if (newNode.data < node.data) {",
            "            if (node.left === null)",
            "                node.left = newNode;",
            "            else",
            "                this.insertNode(node.left, newNode);",
            "        } else {",
            "            if (node.right === null)",
            "                node.right = newNode;",
            "            else",
            "                this.insertNode(node.right,newNode);",
            "        };",
            "    };",
            "};",
            "const BST = new BinarySearchTree();",
            "BST.insert(1);",
            "BST.insert(3);",
            "BST.insert(2);",
        ],
        "description": "Binary Search Tree"
    },
    "AVL Tree": {
        "prefix": "#tree-avl",
        "body": [
            "const Node = (item) => {",
            "    this.item = item;",
            "    this.height = 1;",
            "    this.left = null;",
            "    this.right = null;",
            "}",
            "",
            "const AVLTree = () => {",
            "    let root = null;",
            "    ",
            "    // return height of node",
            "    this.height = (N) => {",
            "        if (N === null) return 0;",
            "        return N.height;",
            "    }",
            "  ",
            "    // right rotate",
            "    this.rightRotate = (y) => {",
            "        let x = y.left;",
            "        let T2 = x.right;",
            "        x.right = y;",
            "        y.left = T2;",
            "        y.height = Math.max(this.height(y.left), this.height(y.right)) + 1;",
            "        x.height = Math.max(this.height(x.left), this.height(x.right)) + 1;",
            "        return x;",
            "    }",
            "  ",
            "    // left rotate",
            "    this.leftRotate = (x) => {",
            "        let y = x.right;",
            "        let T2 = y.left;",
            "        y.left = x;",
            "        x.right = T2;",
            "        x.height = Math.max(this.height(x.left), this.height(x.right)) + 1;",
            "        y.height = Math.max(this.height(y.left), this.height(y.right)) + 1;",
            "        return y;",
            "    }",
            "  ",
            "    // get balance factor of a node",
            "    this.getBalanceFactor = (N) => {",
            "        if (N == null) return 0;",
            "        return this.height(N.left) - this.height(N.right);",
            "    }",
            "  ",
            "  ",
            "    // helper function to insert a node",
            "    const insertNodeHelper = (node, item) => {",
            "",
            "        // find the position and insert the node",
            "        if (node === null) return (new Node(item));",
            "        ",
            "        if (item < node.item) {",
            "            node.left = insertNodeHelper(node.left, item);",
            "        } else if (item > node.item) {",
            "            node.right = insertNodeHelper(node.right, item);",
            "        } else {",
            "            return node;",
            "        }",
            "        ",
            "        // update the balance factor of each node and balance the tree",
            "        node.height = 1 + Math.max(this.height(node.left), this.height(node.right));",
            "        ",
            "        let balanceFactor = this.getBalanceFactor(node);",
            "        ",
            "        if (balanceFactor > 1) {",
            "            if (item < node.left.item) {",
            "                return this.rightRotate(node);",
            "            } else if (item > node.left.item) {",
            "                node.left = this.leftRotate(node.left);",
            "                return this.rightRotate(node);",
            "            }",
            "        }",
            "        ",
            "        if (balanceFactor < -1) {",
            "            if (item > node.right.item) {",
            "                return this.leftRotate(node);",
            "            } else if (item < node.right.item) {",
            "                node.right = this.rightRotate(node.right);",
            "                return this.leftRotate(node);",
            "            }",
            "        }",
            "        return node;",
            "    }",
            "  ",
            "    // insert a node",
            "    this.insertNode = (item) => {",
            "        root = insertNodeHelper(root, item);",
            "    }",
            "  ",
            "    // get node with min value",
            "    this.nodeWithMinValue = (node) => {",
            "        let current = node;",
            "        while (current.left !== null) current = current.left;",
            "        return current;",
            "    }",
            "  ",
            "    // delete helper",
            "    const deleteNodeHelper = (root, item) => {",
            "",
            "        // find the node to be deleted and remove it",
            "        if (root == null) return root;",
            "        ",
            "        if (item < root.item) {",
            "            root.left = deleteNodeHelper(root.left, item);",
            "        } else if (item > root.item) {",
            "            root.right = deleteNodeHelper(root.right, item);",
            "        } else {",
            "            if ((root.left === null) || (root.right === null)) {",
            "                let temp = null;",
            "                if (temp == root.left)",
            "                    temp = root.right;",
            "                else",
            "                    temp = root.left;",
            "                ",
            "                if (temp == null) {",
            "                    temp = root;",
            "                    root = null;",
            "                } else {",
            "                    root = temp;",
            "                }",
            "            } else {",
            "                let temp = this.nodeWithMinValue(root.right);",
            "                root.item = temp.item;",
            "                root.right = deleteNodeHelper(root.right, temp.item);",
            "            }",
            "        }",
            "        ",
            "        if (root == null) return root;",
            "",
            "        // Update the balance factor of each node and balance the tree",
            "        root.height = Math.max(this.height(root.left), this.height(root.right)) + 1;",
            "        ",
            "        let balanceFactor = this.getBalanceFactor(root);",
            "        if (balanceFactor > 1) {",
            "            if (this.getBalanceFactor(root.left) >= 0) {",
            "                return this.rightRotate(root);",
            "            } else {",
            "                root.left = this.leftRotate(root.left);",
            "                return this.rightRotate(root);",
            "            }",
            "        }",
            "        if (balanceFactor < -1) {",
            "            if (this.getBalanceFactor(root.right) <= 0) {",
            "                return this.leftRotate(root);",
            "            } else {",
            "                root.right = this.rightRotate(root.right);",
            "                return this.leftRotate(root);",
            "            }",
            "        }",
            "        return root;",
            "    }",
            "  ",
            "    // delete a node",
            "    this.deleteNode = (item) => {",
            "        root = deleteNodeHelper(root, item);",
            "    }",
            "  ",
            "    // print the tree in pre - order",
            "    this.preOrder = () => {",
            "        preOrderHelper(root);",
            "    }",
            "  ",
            "    const preOrderHelper = (node) => {",
            "        if (node) {",
            "            console.log(node.item);",
            "            preOrderHelper(node.left);",
            "            preOrderHelper(node.right);",
            "        }",
            "    }",
            "}",
        ],
        "description": "AVL Tree"
    },
    "Red-Black Tree": {
        "prefix": "#tree-redblack",
        "body": [
            "const RED = true;",
            "const BLACK = false;",
            "class Node {",
            "    constructor(key, value) {",
            "        this.key = key;",
            "        this.value = value;",
            "        this.left = null;",
            "        this.right = null;",
            "        this.color = RED;",
            "    }",
            "}",
            "",
            "class RBT {",
            "    constructor() {",
            "        this.root = null;",
            "        this.size = 0;",
            "    }",
            "    isRed(node) {",
            "        if (!node) return BLACK;",
            "        return node.color;",
            "    }",
            "    // Left right red left black",
            "    leftRotate(node) {",
            "        let tmp = node.right;",
            "        node.right = tmp.left;",
            "        tmp.left = node;",
            "        tmp.color = node.color;",
            "        node.color = RED;",
            "        return tmp;",
            "    }",
            "    // Right rotation left red left sub red",
            "    rightRoate(node) {",
            "        let tmp = node.left;",
            "        node.left = tmp.right;",
            "        tmp.right = node;",
            "        tmp.color = node.color;",
            "        node.color = RED;",
            "        return tmp;",
            "    }",
            "    // Color reversal",
            "    flipColors(node) {",
            "        node.color = RED;",
            "        node.left.color = BLACK;",
            "        node.right.color = BLACK;",
            "    }",
            "    add(key, value) {",
            "        this.root = this.addRoot(this.root, key, value);",
            "        this.root.color = BLACK; // Root node is always black",
            "    }",
            "    addRoot(node, key, value) {",
            "        if (!node) {",
            "            this.size++;",
            "            return new Node(key, value);",
            "        }",
            "        if (key < node.key) {",
            "            node.left = this.addRoot(node.left, key, value);",
            "        } else if (key > node.key) {",
            "            node.right = this.addRoot(node.right, key, value);",
            "        } else {",
            "            node.value = value;",
            "        }",
            "        if (this.isRed(node.right) && !this.isRed((node.left))) {",
            "            node = this.leftRotate(node);",
            "        }",
            "        if (this.isRed(node.left) && this.isRed((node.left.left))) {",
            "            node = this.rightRoate(node);",
            "        }",
            "        if (this.isRed(node.left) && this.isRed(node.right)) {",
            "            this.flipColors(node);",
            "        }",
            "        return node;",
            "    }",
            "    isEmpty() {",
            "        return this.size == 0 ? true : false;",
            "    }",
            "    getSize() {",
            "        return this.size;",
            "    }",
            "    contains(key) {",
            "        let ans = '';",
            "        !(function getNode(node, key) {",
            "            if (!node || key == node.key) {",
            "                ans = node;",
            "                return node;",
            "            } else if (key > node.key) {",
            "                return getNode(node.right, key);",
            "            } else {",
            "                return getNode(node.right, key);",
            "            }",
            "        })(this.root, key);",
            "        return !!ans;",
            "    }",
            "    // bst preamble traversal (recursive version)",
            "    preOrder(node = this.root) {",
            "        if (node == null) return;",
            "        console.log(node.key);",
            "        this.preOrder(node.left);",
            "        this.preOrder(node.right);",
            "    }",
            "    preOrderNR() {",
            "        if (this.root == null) return;",
            "        let stack = [];",
            "        stack.push(this.root);",
            "        while (stack.length > 0) {",
            "            let curNode = stack.pop();",
            "            console.log(curNode.key);",
            "            if (curNode.right != null) stack.push(curNode.right);",
            "            if (curNode.left != null) curNode.push(curNode.left);",
            "        }",
            "    }",
            "    // bst middle order traversal",
            "    inOrder(node = this.root) {",
            "        if (node == null) return;",
            "        this.inOrder(node.left);",
            "        console.log(node.key);",
            "        this.inOrder(node.right);",
            "    }",
            "    // bst subsequent traversal",
            "    postOrder(node = this.root) {",
            "        if (node == null) return;",
            "        this.postOrder(node.left);",
            "        this.postOrder(node.right);",
            "        console.log(node.key);",
            "    }",
            "    // The way of bsf + queue to realize hierarchical traversal",
            "    generateDepthString1() {",
            "        let queue = [];",
            "        queue.unshift(this.root);",
            "        while (queue.length > 0) {",
            "            let tmpqueue = []; let ans = [];",
            "            queue.forEach(item => {",
            "                ans.push(item.key);",
            "                item.left ? tmpqueue.push(item.left) : '';",
            "                item.right ? tmpqueue.push(item.right) : '';",
            "            });",
            "            console.log(...ans);",
            "            queue = tmpqueue;",
            "        }",
            "    }",
            "    minmun(node = this.root) {",
            "        if (node.left == null) return node;",
            "        return this.minmun(node.left);",
            "    }",
            "    maximum(node = this.root) {",
            "        if (node.right == null) return node;",
            "        return this.maximum(node.right);",
            "    }",
            "}",
            "",
            "let btins = new RBT();",
            "let ary = [5, 3, 6, 8, 4, 2];",
            "",
            "ary.forEach(value => btins.add(value));",
            "btins.generateDepthString1();",
            "",
            "console.log(btins.minmun());  // 2",
            "console.log(btins.maximum()); // 8",
        ],
        "description": "Red-Black Tree"
    },
    "Graph (BFS + DFS supported)": {
        "prefix": "#graph",
        "body": [
            "class Graph {",
            "    constructor(noOfVertices) {",
            "        this.noOfVertices = noOfVertices;",
            "        this.AdjList = new Map();",
            "    }",
            "",
            "    addVertex(v) {",
            "        // initialize the adjacent list with null array",
            "        this.AdjList.set(v, []);",
            "    }",
            "    ",
            "    addEdge(v, w) {",
            "        // get the list for vertex v and put the vertex w denoting edge between v and w",
            "        this.AdjList.get(v).push(w);",
            "",
            "        // Since graph is undirected, add an edge from w to v also",
            "        this.AdjList.get(w).push(v);",
            "    }",
            "    ",
            "    printGraph() {",
            "        // get all vertices",
            "        var get_keys = this.AdjList.keys();",
            "",
            "        // iterate over vertices",
            "        for (var i of get_keys) {",
            "            // get the corresponding adjacency list for the vertex",
            "            var get_values = this.AdjList.get(i);",
            "            var conc = \"\";",
            "",
            "            // iterate over the adjacency list and concatenate the values into a string",
            "            for (var j of get_values)",
            "                conc += j + \" \";",
            "",
            "            // print the vertex and its adjacency list",
            "            console.log(i + \" -> \" + conc);",
            "        }",
            "    }",
            "",
            "    // Breadth First Search",
            "    bfs(startingNode) {",
            "        // create a visited object",
            "        var visited = {};",
            "",
            "        // Create an object for queue",
            "        var q = new Queue();",
            "",
            "        // add the starting node to the queue",
            "        visited[startingNode] = true;",
            "        q.enqueue(startingNode);",
            "",
            "        // loop until queue is empty",
            "        while (!q.isEmpty()) {",
            "            // get the element from the queue",
            "            var getQueueElement = q.dequeue();",
            "",
            "            // passing the current vertex to callback function",
            "            console.log(getQueueElement);",
            "",
            "            // get the adjacent list for current vertex",
            "            var get_List = this.AdjList.get(getQueueElement);",
            "",
            "            // loop through the list and add the element to the",
            "            // queue if it is not processed yet",
            "            for (var i in get_List) {",
            "                var neigh = get_List[i];",
            "",
            "                if (!visited[neigh]) {",
            "                    visited[neigh] = true;",
            "                    q.enqueue(neigh);",
            "                }",
            "            }",
            "        }",
            "    }",
            "",
            "    // Depth First Search",
            "    dfs(startingNode) {",
            "        var visited = {};",
            "        this.DFSUtil(startingNode, visited);",
            "    }",
            "",
            "    // Recursive function which processes & explores all adjacent vertex of vertex with which it is called",
            "    DFSUtil(vert, visited) {",
            "        visited[vert] = true;",
            "        console.log(vert);",
            "",
            "        var get_neighbours = this.AdjList.get(vert);",
            "",
            "        for (var i in get_neighbours) {",
            "            var get_elem = get_neighbours[i];",
            "            if (!visited[get_elem])",
            "                this.DFSUtil(get_elem, visited);",
            "        }",
            "    }",
            "}",
            "",
            "// IMPLEMENTATION",
            "var g = new Graph(6);",
            "var vertices = [ 'A', 'B', 'C', 'D', 'E', 'F' ];",
            "",
            "// adding vertices",
            "for (var i = 0; i < vertices.length; i++) {",
            "       g.addVertex(vertices[i]);",
            "}",
            "",
            "// adding edges",
            "g.addEdge('A', 'B');",
            "g.addEdge('A', 'D');",
            "g.addEdge('A', 'E');",
            "g.addEdge('B', 'C');",
            "g.addEdge('D', 'E');",
            "g.addEdge('E', 'F');",
            "g.addEdge('E', 'C');",
            "g.addEdge('C', 'F');",
            "",
            "// prints all vertex and its adjacency list",
            "g.printGraph();",
            "// A -> B D E",
            "// B -> A C",
            "// C -> B E F",
            "// D -> A E",
            "// E -> A D F C",
            "// F -> E C",
        ],
        "description": "Create Graph"
    },
    "Sieve of Eratosthenes": {
        "prefix": "#sieve-erat",
        "body": [
            "const findPrimes = (num = 10) => {",
            "    const numArr = new Array(num + 1);",
            "    numArr.fill(true);",
            "    numArr[0] = numArr[1] = false;",
            "    for (let i = 2; i <= Math.sqrt(num); i++) {",
            "        for (let j = 2; i * j <= num; j++){",
            "            numArr[i * j] = false;",
            "        }",
            "    }",
            "    return numArr.reduce((acc, val, ind) => {",
            "        if(val){",
            "            return acc.concat(ind);",
            "        }else{",
            "            return acc;",
            "        };",
            "    },[]);",
            "};",
            "console.log(findPrimes(${1:numHere}));",
        ],
        "description": "Sieve of Eratosthenes (primes up to n)"
    },
    "Sieve of Atkin": {
        "prefix": "#sieve-atkin",
        "body": [
            "const sieveOfAtkin = (limit) => {",
            "    var limitSqrt = Math.sqrt(limit);",
            "    var sieve = [];",
            "    var n;",
            "",
            "    //prime start from 2, and 3",
            "    sieve[2] = true;",
            "    sieve[3] = true;",
            "",
            "    for (var x = 1; x <= limitSqrt; x++) {",
            "        var xx = x*x;",
            "        ",
            "        for (var y = 1; y <= limitSqrt; y++) {",
            "            var yy = y*y;",
            "            ",
            "            if (xx + yy >= limit) break;",
            "            ",
            "            // first quadratic using m = 12 and r in R1 = {r : 1, 5}",
            "            n = (4 * xx) + (yy);",
            "            if (n <= limit && (n % 12 == 1 || n % 12 == 5)) sieve[n] = !sieve[n];",
            "            ",
            "            // second quadratic using m = 12 and r in R2 = {r : 7}",
            "            n = (3 * xx) + (yy);",
            "            if (n <= limit && (n % 12 == 7)) sieve[n] = !sieve[n];",
            "            ",
            "            // third quadratic using m = 12 and r in R3 = {r : 11}",
            "            n = (3 * xx) - (yy);",
            "            if (x > y && n <= limit && (n % 12 == 11)) sieve[n] = !sieve[n];",
            "        }",
            "    }",
            "",
            "    // false each primes multiples",
            "    for (n = 5; n <= limitSqrt; n++) {",
            "        if (sieve[n]) {",
            "            x = n * n;",
            "            for (var i = x; i <= limit; i += x) {",
            "                sieve[i] = false;",
            "            }",
            "        }",
            "    }",
            "",
            "    //primes values are the one which sieve[x] = true",
            "    return sieve;",
            "}",
            "",
            "primes = sieveOfAtkin(5000);",
        ],
        "description": "Sieve of Atkin (primes up to n)"
    },
    "Wilson's Theorem": {
        "prefix": "#wilson-thm",
        "body": [
            "const fact = (num) => {",
            "    return (num <= 1 ? num : num * fact(num - 1));",
            "}",
            "",
            "const isPrime = (p) => {",
            "    var f = fact(p - 1);",
            "    return ((f + 1) % p) == 0;",
            "}",
            "",
            "console.log(isPrime(${1:numHere}))",
        ],
        "description": "Wilson's Theorem (Primality Test)"
    },
    "Prime Factorization": {
        "prefix": "#prime-factr",
        "body": [
            "const primeFactors = (n) => {",
            "    const factors = [];",
            "    let divisor = 2;",
            "",
            "    while (n >= 2) {",
            "        if (n % divisor == 0) {",
            "            factors.push(divisor);",
            "            n = n / divisor;",
            "        } else {",
            "            divisor++;",
            "        }",
            "    }",
            "    return factors;",
            "}",
            "console.log(primeFactors(${1:numHere}))",
        ],
        "description": "Prime Factorization"
    },
    "Euler's Totient Function": {
        "prefix": "#euler-totient-fx",
        "body": [
            "const phi = (n) => {",
            "    var count = \" \";",
            "    for (var i = 1; i <= n; i++) {",
            "        if (for (var j = 1; j <= i; j++) {",
            "            i % j === 0;",
            "            n % j === 0;",
            "            count += j.str;",
            "        }) {",
            "            return count.length;",
            "        }",
            "    }",
            "};",
            "console.log(phi(${1:numHere}))",
        ],
        "description": "Euler's Totient Function (counts # of positive ints less than n that are coprime to n)"
    },
    "Modular Exponentiation": {
        "prefix": "#mod-exp",
        "body": [
            "/* Fast modular exponentiation for a ^ b mod n */",
            "const ModularExponentiation = function(a, b, n) {",
            "    a = a % n;",
            "    var result = 1;",
            "    var x = a;",
            "",
            "    while(b > 0){",
            "        var leastSignificantBit = b % 2;",
            "        b = Math.floor(b / 2);",
            "",
            "        if (leastSignificantBit == 1) {",
            "        result = result * x;",
            "        result = result % n;",
            "        }",
            "",
            "        x = x * x;",
            "        x = x % n;",
            "    }",
            "    return result;",
            "};",
            "",
            "console.log(fastModularExponentiation(12, 53, 7)); // (12 ^ 53) mod 7 = 3",
        ],
        "description": "Modular Exponentiation"
    },
    "Recursive Factorization": {
        "prefix": "#factorial-rec",
        "body": [
            "const RecFact = (num) => {",
            "    return (num === 0) ? 1 : num * rFact( num - 1 );",
            "}",
            "console.log(RecFact(${1:numHere}))",
        ],
        "description": "Recursive Factorization"
    },
    "Iterative Factorization": {
        "prefix": "#factorial-itr",
        "body": [
            "const ItrFact = (num) => {",
            "    var result = 1;",
            "    for (var i = 2; i <= num; i++)",
            "        result *= * i;",
            "    return result;",
            "}",
            "console.log(ItrFact(${1:numHere}))",
        ],
        "description": "Iterative Factorization"
    },
    "Pascal's Triangle": {
        "prefix": "#pascal-tri",
        "body": [
            "const PascalTri = (numRows) => {",
            "    if (numRows === 0) return [];",
            "    if (numRows === 1) return [[1]];",
            "    let result = [];",
            "    for (let row = 1; row <= numRows; row++) {",
            "        let arr = [];",
            "        for (let col = 0; col < row; col++) {",
            "            if (col === 0 || col === row - 1)",
            "                arr.push(1);",
            "            else",
            "                arr.push((result[row-2][col-1] + result[row-2][col]));",
            "        }",
            "        result.push(arr);",
            "    }",
            "    return result;",
            "}",
            "console.log(PascalTri(${1:numRowsHere}))",
        ],
        "description": "Pascal's Triangle"
    },
    "Euclidean Distance": {
        "prefix": "#eucl-dist",
        "body": [
            "// Calculates the distance between two points in any number of dimensions (Nd array)",
            "const euclideanDistance = (a, b) => {",
            "    return Math.hypot(...Object.keys(a).map(k => b[k] - a[k]));",
            "}",
            "",
            "console.log(euclideanDistance([1, 1], [2, 3])); // ~2.2361",
            "console.log(euclideanDistance([1, 1, 1], [2, 3, 2])); // ~2.4495",
        ],
        "description": "Euclidean Distance (for any number of dimensions)"
    },
}