{
    "Selection Sort": {
        "prefix": "$slctn-srt",
        "body": [
            "let selectionSort = (inputArr) => { ",
            "    let n = inputArr.length;",
            "        ",
            "    for(let i = 0; i < n; i++) {",
            "        // Finding the smallest number in the subarray",
            "        let min = i;",
            "        for(let j = i+1; j < n; j++){",
            "            if(inputArr[j] < inputArr[min]) {",
            "                min=j; ",
            "            }",
            "         }",
            "         if (min != i) {",
            "             // Swapping the elements",
            "             let tmp = inputArr[i]; ",
            "             inputArr[i] = inputArr[min];",
            "             inputArr[min] = tmp;      ",
            "        }",
            "    }",
            "    return inputArr;",
            "};",
        ],
        "description": "Selection Sorting Algorithm"
    },
    "Insertion Sort": {
        "prefix": "$ins-srt",
        "body": [
            "let insertionSort = (inputArr) => {",
            "    let n = inputArr.length;",
            "        for (let i = 1; i < n; i++) {",
            "            // Choosing the first element in our unsorted subarray",
            "            let current = inputArr[i];",
            "            // The last element of our sorted subarray",
            "            let j = i-1; ",
            "            while ((j > -1) && (current < inputArr[j])) {",
            "                inputArr[j+1] = inputArr[j];",
            "                j--;",
            "            }",
            "            inputArr[j+1] = current;",
            "        }",
            "    return inputArr;",
            "};",
        ],
        "description": "Insertion Sorting Algorithm"
    },
    "Bubble Sort": {
        "prefix": "$bbl-srt",
        "body": [
            "let bubbleSort = (inputArr) => {",
            "    let len = inputArr.length;",
            "    for (let i = 0; i < len; i++) {",
            "        for (let j = 0; j < len; j++) {",
            "            if (inputArr[j] > inputArr[j + 1]) {",
            "                let tmp = inputArr[j];",
            "                inputArr[j] = inputArr[j + 1];",
            "                inputArr[j + 1] = tmp;",
            "            }",
            "        }",
            "    }",
            "    return inputArr;",
            "};",
        ],
        "description": "Bubble Sorting Algorithm"
    },
    "Shell Sort": {
        "prefix": "$shell-srt",
        "body": [
            "let shellSort = (inputArr) => {",
            "    let n = inputArr.length;",
            "    for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2))   {",
            "        for (let i = gap; i < n; i += 1)  {",
            "            let temp = inputArr[i];",
            "            let j;",
            "            for (j = i; j >= gap && inputArr[j-gap] > temp; j-=gap)  {",
            "                inputArr[j] = inputArr[j-gap];",
            "            }",
            "            inputArr[j] = temp;",
            "        }",
            "    }",
            "    return inputArr;",
            "};",
        ],
        "description": "Shell Sorting Algorithm"
    },
    "Merge Sort": {
        "prefix": "$mrg-srt",
        "body": [
            "let merge = (left, right) => {",
            "    let arr = []",
            "    while (left.length && right.length) {",
            "        if (left[0] < right[0]) {",
            "            arr.push(left.shift())  ",
            "        } else {",
            "            arr.push(right.shift()) ",
            "        }",
            "    }",
            "    return [ ...arr, ...left, ...right ]",
            "};",
            "",
            "let mergeSort = (array) => {",
            "    const half = array.length / 2",
            "    if(array.length < 2){",
            "        return array ",
            "    }",
            "    const left = array.splice(0, half)",
            "    return merge(mergeSort(left),mergeSort(array))",
            "};",
        ],
        "description": "Merge Sorting Algorithm"
    },
    "Quick Sort": {
        "prefix": "$qk-srt",
        "body": [
            "let partition = (arr, start, end) => {",
            "    const pivotValue = arr[end];",
            "    let pivotIndex = start; ",
            "    for (let i = start; i < end; i++) {",
            "        if (arr[i] < pivotValue) {",
            "        [arr[i], arr[pivotIndex]] = [arr[pivotIndex], arr[i]];",
            "        pivotIndex++;",
            "        }",
            "    }",
            "    [arr[pivotIndex], arr[end]] = [arr[end], arr[pivotIndex]] ",
            "    return pivotIndex;",
            "};",
            "",
            "function quickSortRecursive(arr, start, end) {",
            "    if (start >= end) return;",
            "    let index = partition(arr, start, end);",
            "    quickSort(arr, start, index - 1);",
            "    quickSort(arr, index + 1, end);",
            "};",
        ],
        "description": "Quick Sorting Algorithm"
    },
    "Heap Sort": {
        "prefix": "$hp-srt",
        "body": [
            "const maxHeapify = (arr, n, i) => {",
            "    let largest = i;",
            "    let l = 2 * i + 1; //left child index",
            "    let r = 2 * i + 2; //right child index",
            "  ",
            "    //If left child is smaller than root",
            "    if (l < n && arr[l] > arr[largest]) largest = l;",
            "  ",
            "    // If right child is smaller than smallest so far ",
            "    if (r < n && arr[r] > arr[largest]) largest = r;",
            "  ",
            "    // If smallest is not root ",
            "    if (largest != i) { ",
            "        let temp = arr[i];",
            "        arr[i] = arr[largest];",
            "        arr[largest] = temp;",
            "        // Recursively heapify the affected sub-tree",
            "        maxHeapify(arr, n, largest);",
            "    }",
            "};",
            "",
            "// main function to do heap sort ",
            "const heapSort = (arr, n) => { ",
            "    // Build heap (rearrange array) ",
            "    for (let i = parseInt(n / 2 - 1); i >= 0; i--) maxHeapify(arr, n, i);",
            "    ",
            "    // One by one extract an element from heap",
            "    for (let i = n - 1; i >= 0; i--) {",
            "        // Move current root to end",
            "        let temp = arr[0];",
            "        arr[0] = arr[i];",
            "        arr[i] = temp;",
            "        // call max heapify on the reduced heap",
            "        maxHeapify(arr, i, 0);",
            "    }",
            "};",
        ],
        "description": "Heap Sorting Algorithm"
    },
    "Counting Sort": {
        "prefix": "$cnt-srt",
        "body": [
            "let countingSort = (arr, min, max) => {",
            "    let i = min,",
            "        j = 0,",
            "        len = arr.length,",
            "        count = [];",
            "    for (i; i <= max; i++) count[i] = 0;",
            "    for (i = 0; i < len; i++) count[arr[i]] += 1;",
            "    for (i = min; i <= max; i++) {",
            "        while (count[i] > 0) {",
            "            arr[j] = i;",
            "            j++;",
            "            count[i]--;",
            "        }",
            "    }",
            "    return arr;",
            "};",
        ],
        "description": "Counting Sort Algorithm"
    },
    "Radix Sort": {
        "prefix": "$rx-srt",
        "body": [
            "const getDigitAtPosition = (num, atPosition) => Math.floor(Math.abs(num) / Math.pow(10, atPosition)) % 10",
            "",
            "const radixSort = (arr) => {",
            "    if (!arr.length || arr.length === 1) return arr",
            "",
            "    let biggestNumber = arr[arr.length-1]",
            "    for (let i = 0; i < arr.length; i++) {",
            "        if (arr[i] > biggestNumber) biggestNumber = arr[i]",
            "    }",
            "    const biggestNumberPositionsCount = biggestNumber.toString().length",
            "  ",
            "    for (let position = 0; position < biggestNumberPositionsCount; position++) {",
            "        let buckets = Array.from({length:10}, () => []) ",
            "    ",
            "        for (let i = 0; i < arr.length; i++) {",
            "            buckets[getDigitAtPosition(arr[i], position)].push(arr[i])",
            "        }",
            "        arr = [].concat(...buckets)",
            "    }",
            "    return arr",
            "};",
        ],
        "description": "Radix Sort Algorithm"
    }
}