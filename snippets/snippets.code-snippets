{
    "Selection Sort": {
        "prefix": "$slctn-srt",
        "body": [
            "let selectionSort = (inputArr) => { ",
            "    let n = inputArr.length;",
            "        ",
            "    for(let i = 0; i < n; i++) {",
            "        // Finding the smallest number in the subarray",
            "        let min = i;",
            "        for(let j = i+1; j < n; j++){",
            "            if(inputArr[j] < inputArr[min]) {",
            "                min=j; ",
            "            }",
            "         }",
            "         if (min != i) {",
            "             // Swapping the elements",
            "             let tmp = inputArr[i]; ",
            "             inputArr[i] = inputArr[min];",
            "             inputArr[min] = tmp;      ",
            "        }",
            "    }",
            "    return inputArr;",
            "};",
            "console.log(selectionSort(${1:arrHere}))",
        ],
        "description": "Selection Sorting Algorithm"
    },
    "Insertion Sort": {
        "prefix": "$ins-srt",
        "body": [
            "let insertionSort = (inputArr) => {",
            "    let n = inputArr.length;",
            "        for (let i = 1; i < n; i++) {",
            "            // Choosing the first element in our unsorted subarray",
            "            let current = inputArr[i];",
            "            // The last element of our sorted subarray",
            "            let j = i-1; ",
            "            while ((j > -1) && (current < inputArr[j])) {",
            "                inputArr[j+1] = inputArr[j];",
            "                j--;",
            "            }",
            "            inputArr[j+1] = current;",
            "        }",
            "    return inputArr;",
            "};",
            "console.log(insertionSort(${1:arrHere}))",
        ],
        "description": "Insertion Sorting Algorithm"
    },
    "Bubble Sort": {
        "prefix": "$bbl-srt",
        "body": [
            "let bubbleSort = (inputArr) => {",
            "    let len = inputArr.length;",
            "    for (let i = 0; i < len; i++) {",
            "        for (let j = 0; j < len; j++) {",
            "            if (inputArr[j] > inputArr[j + 1]) {",
            "                let tmp = inputArr[j];",
            "                inputArr[j] = inputArr[j + 1];",
            "                inputArr[j + 1] = tmp;",
            "            }",
            "        }",
            "    }",
            "    return inputArr;",
            "};",
            "console.log(bubbleSort(${1:arrHere}))",
        ],
        "description": "Bubble Sorting Algorithm"
    },
    "Shell Sort": {
        "prefix": "$shell-srt",
        "body": [
            "let shellSort = (inputArr) => {",
            "    let n = inputArr.length;",
            "    for (let gap = Math.floor(n/2); gap > 0; gap = Math.floor(gap/2))   {",
            "        for (let i = gap; i < n; i += 1)  {",
            "            let temp = inputArr[i];",
            "            let j;",
            "            for (j = i; j >= gap && inputArr[j-gap] > temp; j-=gap)  {",
            "                inputArr[j] = inputArr[j-gap];",
            "            }",
            "            inputArr[j] = temp;",
            "        }",
            "    }",
            "    return inputArr;",
            "};",
            "console.log(shellSort(${1:arrHere}))",
        ],
        "description": "Shell Sorting Algorithm"
    },
    "Merge Sort": {
        "prefix": "$mrg-srt",
        "body": [
            "let merge = (left, right) => {",
            "    let arr = []",
            "    while (left.length && right.length) {",
            "        if (left[0] < right[0]) {",
            "            arr.push(left.shift())  ",
            "        } else {",
            "            arr.push(right.shift()) ",
            "        }",
            "    }",
            "    return [ ...arr, ...left, ...right ]",
            "};",
            "",
            "let mergeSort = (array) => {",
            "    const half = array.length / 2",
            "    if(array.length < 2){",
            "        return array ",
            "    }",
            "    const left = array.splice(0, half)",
            "    return merge(mergeSort(left),mergeSort(array))",
            "};",
            "console.log(mergeSort(${1:arrHere}))",
        ],
        "description": "Merge Sorting Algorithm"
    },
    "Quick Sort": {
        "prefix": "$qk-srt",
        "body": [
            "let partition = (arr, start, end) => {",
            "    const pivotValue = arr[end];",
            "    let pivotIndex = start; ",
            "    for (let i = start; i < end; i++) {",
            "        if (arr[i] < pivotValue) {",
            "        [arr[i], arr[pivotIndex]] = [arr[pivotIndex], arr[i]];",
            "        pivotIndex++;",
            "        }",
            "    }",
            "    [arr[pivotIndex], arr[end]] = [arr[end], arr[pivotIndex]] ",
            "    return pivotIndex;",
            "};",
            "",
            "function quickSortRecursive(arr, start, end) {",
            "    if (start >= end) return;",
            "    let index = partition(arr, start, end);",
            "    quickSort(arr, start, index - 1);",
            "    quickSort(arr, index + 1, end);",
            "};",
            "console.log(quickSortRecursive(${1:arrHere}))",
        ],
        "description": "Quick Sorting Algorithm"
    },
    "Heap Sort": {
        "prefix": "$hp-srt",
        "body": [
            "const maxHeapify = (arr, n, i) => {",
            "    let largest = i;",
            "    let l = 2 * i + 1; //left child index",
            "    let r = 2 * i + 2; //right child index",
            "  ",
            "    if (l < n && arr[l] > arr[largest]) largest = l;",
            "  ",
            "    if (r < n && arr[r] > arr[largest]) largest = r;",
            "  ",
            "    if (largest != i) { ",
            "        let temp = arr[i];",
            "        arr[i] = arr[largest];",
            "        arr[largest] = temp;",
            "        maxHeapify(arr, n, largest);",
            "    }",
            "};",
            "",
            "const heapSort = (arr, n) => { ",
            "    for (let i = parseInt(n / 2 - 1); i >= 0; i--) maxHeapify(arr, n, i);",
            "    ",
            "    for (let i = n - 1; i >= 0; i--) {",
            "        let temp = arr[0];",
            "        arr[0] = arr[i];",
            "        arr[i] = temp;",
            "        maxHeapify(arr, i, 0);",
            "    }",
            "};",
            "console.log(heapSort(${1:arrHere}, ${2:arrLengthHere}))",
        ],
        "description": "Heap Sorting Algorithm"
    },
    "Counting Sort": {
        "prefix": "$cnt-srt",
        "body": [
            "let countingSort = (arr, min, max) => {",
            "    let i = min,",
            "        j = 0,",
            "        len = arr.length,",
            "        count = [];",
            "    for (i; i <= max; i++) count[i] = 0;",
            "    for (i = 0; i < len; i++) count[arr[i]] += 1;",
            "    for (i = min; i <= max; i++) {",
            "        while (count[i] > 0) {",
            "            arr[j] = i;",
            "            j++;",
            "            count[i]--;",
            "        }",
            "    }",
            "    return arr;",
            "};",
            "console.log(countingSort(${1:arrHere}, ${2:minValHere}, ${3:maxValHere}))",
        ],
        "description": "Counting Sort Algorithm"
    },
    "Radix Sort": {
        "prefix": "$rx-srt",
        "body": [
            "const getDigitAtPosition = (num, atPosition) => Math.floor(Math.abs(num) / Math.pow(10, atPosition)) % 10",
            "",
            "const radixSort = (arr) => {",
            "    if (!arr.length || arr.length === 1) return arr",
            "",
            "    let biggestNumber = arr[arr.length-1]",
            "    for (let i = 0; i < arr.length; i++) {",
            "        if (arr[i] > biggestNumber) biggestNumber = arr[i]",
            "    }",
            "    const biggestNumberPositionsCount = biggestNumber.toString().length",
            "  ",
            "    for (let position = 0; position < biggestNumberPositionsCount; position++) {",
            "        let buckets = Array.from({length:10}, () => []) ",
            "    ",
            "        for (let i = 0; i < arr.length; i++) {",
            "            buckets[getDigitAtPosition(arr[i], position)].push(arr[i])",
            "        }",
            "        arr = [].concat(...buckets)",
            "    }",
            "    return arr",
            "};",
            "console.log(radixSort(${1:arrHere}))",
        ],
        "description": "Radix Sorting Algorithm"
    },
    "Linear Search": {
        "prefix": "$lin-srch",
        "body": [
            "let linearSearch = (arr, value) => {",
            "    let found = false;",
            "    let position = -1;",
            "    let index = 0;",
            "  ",
            "    while(!found && index < arr.length) {",
            "        if(arr[index] == value) {",
            "            found = true;",
            "            position = index;",
            "        } else {",
            "            index += 1;",
            "        }",
            "    }",
            "    return position;",
            "};",
            "console.log(linearSearch(${1:arrHere}, ${2:targetValHere}))",
        ],
        "description": "Linear Search Algorithm"
    },
    "Binary Search": {
        "prefix": "$bi-srch",
        "body": [
            "let binarySearch = (sortedArray, target) => {",
            "    let start = 0;",
            "    let end = sortedArray.length - 1;",
            "",
            "    while (start <= end) {",
            "        let middle = Math.floor((start + end) / 2);",
            "",
            "        if (sortedArray[middle] === target) {",
            "            return middle;",
            "        } else if (sortedArray[middle] < target) {",
            "            start = middle + 1;",
            "        } else {",
            "            end = middle - 1;",
            "        }",
            "    }",
            "    return -1;",
            "};",
            "console.log(binarySearch(${1:sortedArrHere}, ${2:targetValHere}))",
        ],
        "description": "Binary Search Algorithm"
    },
    "Jump Search": {
        "prefix": "$jmp-srch",
        "body": [
            "let jumpSearch = (arr, target) => {",
            "    let len = arr.length",
            "    let step = Math.floor(Math.sqrt(len));",
            "    let blockStart = 0, currentStep = step;",
            "",
            "    while (arr[Math.min(currentStep, len) - 1] < target) {",
            "        blockStart = currentStep;",
            "        currentStep += step;",
            "        if (blockStart >= len) return -1;",
            "    }",
            "    while (arr[blockStart] < target) {",
            "        blockStart++;",
            "        if (blockStart == Math.min(currentStep, len)) return -1;",
            "    }",
            "    return (arr[blockStart] == target) ? blockStart : -1",
            "};",
            "console.log(jumpSearch(${1:arrHere}, ${2:targetValHere}))",
        ],
        "description": "Jump Search Algorithm"
    },
    "Interpolation Search": {
        "prefix": "$intrpl-srch",
        "body": [
            "let interpolationSearch = (sortedArr, target) => {",
            "    let left = 0;",
            "    let right = sortedArr.length - 1;",
            "    while (left <= right) {",
            "        const rangeDelta = sortedArr[right] - sortedArr[left];",
            "        const indexDelta = right - left;",
            "        const valueDelta = target - sortedArr[left];",
            "        ",
            "        if (valueDelta < 0) return -1;",
            "        if (!rangeDelta) return sortedArr[left] === target ? left : -1;",
            "        ",
            "        const middleIndex = left + Math.floor((valueDelta * indexDelta) / rangeDelta);",
            "        ",
            "        if (sortedArr[middleIndex] === target) return middleIndex;",
            "        if (sortedArr[middleIndex] < target)",
            "            left = middleIndex + 1;",
            "        else",
            "            right = middleIndex - 1;",
            "    }",
            "    return -1;",
            "};",
            "console.log(interpolation(${1:sortedArrHere}, ${2:targetValHere}))",
        ],
        "description": "Interpolation Search Algorithm"
    },
    "Fibonacci Search": {
        "prefix": "$fib-srch",
        "body": [
            "let fibMonaccianSearch = (arr, target, n) => {",
            "    let fibMMm2 = 0;",
            "    let fibMMm1 = 1;",
            "    let fibM = fibMMm2 + fibMMm1;",
            "  ",
            "    while (fibM < n) {",
            "        fibMMm2 = fibMMm1;",
            "        fibMMm1 = fibM;",
            "        fibM = fibMMm2 + fibMMm1;",
            "    }",
            "    let offset = -1;",
            "    ",
            "    while (fibM > 1) {",
            "        let i = Math.min(offset + fibMMm2, n-1);",
            "        if (arr[i] < target) {",
            "            fibM = fibMMm1;",
            "            fibMMm1 = fibMMm2;",
            "            fibMMm2 = fibM - fibMMm1;",
            "            offset = i;",
            "        } else if (arr[i] > target) {",
            "            fibM = fibMMm2;",
            "            fibMMm1 = fibMMm1 - fibMMm2;",
            "            fibMMm2 = fibM - fibMMm1;",
            "        }",
            "        else return i;",
            "    }",
            "",
            "    if (fibMMm1 && arr[n-1] == target) return n-1;",
            "  ",
            "    // element not found. return -1",
            "    return -1;",
            "};",
            "console.log(fibMonaccianSearch(${1:arrHere}, ${2:targetValHere}, ${3:arrLengthHere}))",
        ],
        "description": "Fibonacci Search Algorithm"
    },
    "Array": {
        "prefix": "#arr",
        "body": [
            "const arrName = [\"el1\", \"el2\", \"el3\"]",
        ],
        "description": "Create Array"
    },
    "Array Uniques": {
        "prefix": "#arr-uniques",
        "body": [
            "const getUniqueValues = (arrOfNum) => {",
                "const set = new Set(arrOfNum);",
                "return [...set];",
            "}"
        ],
        "description": "Return Unique Values of Array"
    },
    "Array Permutations": {
        "prefix": "#arr-permutations",
        "body": [
            "const permute = (nums) => {",
            "    let result = [];",
            "    let backtrack = (i, nums) => {",
            "        if(i===nums.length){",
            "            result.push(nums.slice());",
            "            return;",
            "        }  ",
            "        for(let j = i; j < nums.length; j++){",
            "            [nums[i],nums[j]] = [nums[j],nums[i]];",
            "            backtrack(i+1, nums);",
            "            [nums[i],nums[j]] = [nums[j],nums[i]];",
            "        }",
            "    }",
            "    backtrack(0, nums);",
            "    return result;",
            "};",
            "const permutations = permute(${1:arrHere});"
        ],
        "description": "Return 2D Array of Possible Permutations"
    },
    "Array Shuffle": {
        "prefix": "#arr-shuffle",
        "body": [
            "const shuffleArray = array => {",
            "    for (let i = array.length - 1; i > 0; i--) {",
            "        const j = Math.floor(Math.random() * (i + 1));",
            "        [array[i], array[j]] = [array[j], array[i]];",
            "    }",
            "};",
            "",
            "shuffleArray(${1:arrHere});",
            "console.log(${1:arrHere});",
        ],
        "description": "Return Shuffled Array"
    },
    "Array For-Each Traversal": {
        "prefix": "#arr-trav",
        "body": [
            "${1:arrHere}.forEach((item, index) => {",
            "    console.log(item, index);",
            "});",
        ],
        "description": "For-Each Traversal of Array"
    },
    "Array For-Each Reverse Traversal": {
        "prefix": "#arr-revtrav",
        "body": [
            "${1:arrHere}.slice().reverse().forEach((item, index) => {",
            "    console.log(item, index);",
            "});",
        ],
        "description": "For-Each Reverse Traversal of Array"
    },
    "Queue (Class Implementation)": {
        "prefix": "#queue",
        "body": [
            "class Queue {",
            "    constructor() {",
            "        this.items = {};",
            "        this.headIndex = 0;",
            "        this.tailIndex = 0;",
            "    }",
            "    enqueue(item) {",
            "        this.items[this.tailIndex] = item;",
            "        this.tailIndex++;",
            "    }",
            "    dequeue() {",
            "        const item = this.items[this.headIndex];",
            "        delete this.items[this.headIndex];",
            "        this.headIndex++;",
            "        return item;",
            "    }",
            "    peek() {",
            "        return this.items[this.headIndex];",
            "    }",
            "    get length() {",
            "        return this.tailIndex - this.headIndex;",
            "    }",
            "}",
            "const queue = new Queue();",
            "queue.enqueue(7);",
            "queue.enqueue(2);",
            "queue.enqueue(6);",
            "queue.enqueue(4);",
            "queue.dequeue(); // 7",
            "queue.peek();    // 2",
            "queue.length;    // 3",
        ],
        "description": "Class Implementation of Queue"
    },
    "Stack (Class Implementation)": {
        "prefix": "#stack",
        "body": [
            "class Stack {",
            "    constructor() {",
            "        this.items = [];",
            "    }",
            "    ",
            "    push(element) {",
            "        this.items.push(element);",
            "    }",
            "    ",
            "    pop() {",
            "        if (this.items.length == 0) return \"Underflow\";",
            "        return this.items.pop();",
            "    }",
            "",
            "    peek() {",
            "        return this.items[this.items.length - 1];",
            "    }",
            "",
            "    isEmpty() {",
            "        return this.items.length == 0;",
            "    }",
            "",
            "    printStack() {",
            "        var str = \"\";",
            "        for (var i = 0; i < this.items.length; i++)",
            "            str += this.items[i] + \" \";",
            "        return str;",
            "    }",
            "}",
            "",
            "// Adding element to the stack",
            "stack.push(10);",
            "stack.push(20);",
            "stack.push(30);",
            "",
            "// Printing the stack element",
            "// prints [10, 20, 30]",
            "console.log(stack.printStack());",
            "",
            "// returns 30",
            "console.log(stack.peek());",
            "",
            "// returns 30 and remove it from stack",
            "console.log(stack.pop());",
            "",
            "// returns [10, 20]",
            "console.log(stack.printStack());",
        ],
        "description": "Class Implementation of Stack"
    },
    "Map": {
        "prefix": "#map",
        "body": [
            "var hashmap = new Map();",
            "",
            "hashmap.set('1', 99);",
            "hashmap.set('2', [1,2,3]);",
            "hashmap.set('3', \"This is a string\");",
            "hashmap.set('4', ()=>{console.log(\"Hello World\")});",
            "",
            "console.log(hashmap);",
        ],
        "description": "Create Map"
    },
    "Map Traversal": {
        "prefix": "#map-trav",
        "body": [
            "hashmap.forEach(element => {",
                "document.write('<br>'+element);",
            "});",
        ],
        "description": "For-Each Traversal of Map"
    },
}